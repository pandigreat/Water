/**
*


    一个整数总可以拆分为2的幂的和，例如：
    7=1+2+4
    7=1+2+2+2
    7=1+1+1+4
    7=1+1+1+2+2
    7=1+1+1+1+1+2
    7=1+1+1+1+1+1+1
    总共有六种不同的拆分方式。
    再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。
    用f(n)表示n的不同拆分的种数，例如f(7)=6.
    要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000。

输入：

    每组输入包括一个整数：N(1<=N<=1000000)。

输出：

    对于每组数据，输出f(n)%1000000000。

样例输入：

    7

样例输出：

    6
*/


#include <stdio.h>
#include<iostream>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<algorithm>
#include<vector>
using namespace std;
int n;
#define N 1000100
int v[N] = {0};
int main(int argc, char** argv)
{
    v[0] = 0; v[1] = 1; v[2] = 2;
    for(int i = 3; i < N; i++){
        if(i % 2 == 0){
            v[i] = (v[i / 2] + v[i - 1]) % 1000000000;
        }else v[i] = v[i - 1];
    }
    while(~scanf("%d", &n)){
        printf("%d\n", v[n]);
    }

    return 0;
}
/**
*
对于奇数n=2k+1：它的拆分的第一项一定是1，考虑去掉这个1，其实就一一对应于
2k的拆分，因此f(2k+1)=f(2k).

对于偶数n=2k：考虑有1和没有1的拆分。有1的拆分，与(2k-1)的拆分一一对应，与上面奇数的情况
理由相同；没有1的拆分，将每项除以2，正好一一对应于k的所有拆分。因此f(2k)=f(2k-1)+f(k).

*/





